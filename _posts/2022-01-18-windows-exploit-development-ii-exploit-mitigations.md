---
title: "Windows Exploit Development: II. Exploit Mitigations"
date: 2022-01-18
categories: [Exploit Development, Windows] # You can add only 2 categories, comma separated. First is main category and Second is sub-category under the main category.
tags: [exploit, windows] # You can add any number of tags, comma separated. TAG names should always be lowercase. # To add assets to this post in future, create a folder named assets\blogpost_assets\2022-01-18-windows-exploit-development-ii-exploit-mitigations\ and drop your assets in there.
---

<p>The advancement in exploit techniques and mitigations can be thought of as a never ending cat and mouse game where neither side yields. Over a period of time, Microsoft has introduced various security measures to tackle and thwart exploits. We could say Microsoft was fairly successful in doing so and the exploitation is becoming more and more difficult day-by-day. It is a good sign. However, there is a lot of older software lying around without any security features embedded in them. Also, there are so many 'security features' that an average developer finds it very difficult to implement them in his/her code. A lot of awareness and training needs to be given to the developers regarding the secure code. Unless that happens, there will always be some or other vulnerabilities that may be exploited.</p><p>Let's talk about some security measures introduced by Microsoft over the last few years. Some of these are introduced as a compiler options, some as OS features and some as a separate security programs.<br />1. GS Cookie / Stack Cookie / Stack Canary<br />2. DEP<br />3. ASLR<br />4. SafeSEH<br />5.SEHOP<br />6. Control Flow Guard<br />7. EMET<br />8. and Others. </p><p>&nbsp;<a href="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/ExploitMitigations.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="334" data-original-width="800" height="267" src="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/ExploitMitigations.png" width="640" alt="ExploitationMitigations" /></a></p><p></p><p></p><p><span style="color: #04ff00;"><b><u>GS Cookie</u>:</b></span><br />• It is a <span style="color: #b45f06;"><b>compiler option</b></span>. Look at <a href="https://docs.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-check?view=msvc-170" target="_blank">this </a>msdn link to know what buffers are protected by GS Cookie.<br />• can be enabled by <span style="color: #b45f06;"><b>/GS</b></span> and disabled by <span style="color: #b45f06;"><b>/GS-</b></span> [GS Cookie is enabled by default i.e., if you don't specify anything then it is compiled as if /GS is used.]<br />• It is a random value placed on the stack above all the 'important parameters such as SEH record and saved ret ptr' so that when the buffer overflow occurs, the GS cookie is bound to be overwritten before reaching the important parameters. Look at the below diagram to understand this better:</p><div class="separator" style="clear: both; text-align: center;"><a href="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/GSCookie0.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="800" data-original-width="473" height="640" src="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/GSCookie0.png" width="378" alt="GSCookie0"/></a></div><p></p><p>The exact working of the GS Cookie is described below:</p><p>1. First, a call to <span style="color: #b45f06;"><b>_security_init_cookie</b></span> is made to initialize the GS Cookie before a vulnerable function is called. This is important because if it is not called, then the default GS Cookie value is filled and the attacker can easily overwrite this with default value during the overflow thereby defeating the GS Cookie protection. Look at <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170" target="_blank">this </a>msdn link to understand the _security_init_cookie.</p><p>2. Next, whenever a vulnerable function is called, this happens:<br /><span>&nbsp;&nbsp; &nbsp;</span>i. After call,  'saved ret ptr' is pushed onto the stack and we enter the vulnerable function. <br /><span>&nbsp;&nbsp; &nbsp;</span>ii. Function prologue kicks in: <br /><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>push ebp // (saved old ebp) is pushed onto the stack <br /><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>mov ebp, esp <br /><span>&nbsp;&nbsp; &nbsp;</span>iii. 'Exception Handler' pointers are pushed onto the stack if any.<br /><span>&nbsp;&nbsp; &nbsp;</span>iv. Then, the stack cookie is fetched from .data section and xored with ebp and the final cookie value is calculated. This is placed on top of the saved old ebp @ [ebp-4].<br /><span>&nbsp;&nbsp; &nbsp;</span>v. Then, the vulnerable code within the vulnerable function gets executed and the stack gets corrupted.<br /><span>&nbsp;&nbsp; &nbsp;</span>vi. Just before the exiting the vulnerable function, cookie checking takes place as part of the function epilogue.<br /><span>&nbsp;&nbsp; &nbsp;</span>vii. Now, the cookie from the stack is fetched, xored with ebp and compared with the original cookie from the .data section. If it doesn't match, then the program is terminated.<br /><span>&nbsp;&nbsp; &nbsp;</span>viii. This is how a GS Cookie protects the program from stack buffer overflow vulnerabilities.<br /></p><p>However, there is a catch. As you have observed, GS Cookie doesn't automatically prevent stack buffer overflow. In fact the code that actually stops the buffer overflow is the cookie checking code. What if we can generate an exception before the cookie check code? This is what we do exactly to bypass GS Cookie. If we can overwrite a SEH record and if we can generate an exception before the cookie check, then the current SE Handler kicks in. Since we overwrite the SE Handler, we control the execution flow and thereby pass the cookie check code.</p><p>To understand it even better, let's write a small vulnerable C program to study it: gstest.c</p>
<pre><code class="language-c nohljsln">//Author: Narasimha
//compiler option: cl.exe /Zi gstest.c

#include &lt;string.h&gt;

void vuln_func(char* buffer)
{
	char vulnvar[128];
	strcpy(vulnvar, buffer);
}

int main(int argc, char* argv[])
{
	vuln_func(argv[1]);
	printf("Overflow did n't occur!\n");
	return 0;
}</code></pre>

<p>Compile it with: </p><pre><code class="language-c nohljsln">cl.exe /Zi gstest.c</code></pre><p></p><p><span style="color: #b45f06;"><b>/Zi </b></span>flag tells the compiler to create debug info and store it in an external .pdb file. In the debug version, all the symbols will be resolved including the code related to stack cookie. So, it will be easier to identify and study the working of GS Cookie.</p><p>Now, look at the below pictures and read the accompanying text to understand GS Cookie in action:<span style="font-family: &quot;Times New Roman&quot;; font-size: 12pt;"></span><span style="font-family: &quot;Times New Roman&quot;; font-size: 12pt;">&nbsp;</span></p><p></p><p><span style="font-family: &quot;Times New Roman&quot;; font-size: 12pt;"></span></p><p style="text-align: center;"><a href="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/GSCookie1.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="433" data-original-width="800" height="346" src="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/GSCookie1.png" width="640" alt="GSCookie1"/></a></p><div class="separator" style="clear: both; text-align: center;"><a href="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/GSCookie2.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="433" data-original-width="800" height="346" src="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/GSCookie2.png" width="640" alt="GSCookie2"/></a></div><p></p><p>1. First, a call to _security_init_cookie is made to initialize the GS Cookie.<br />2. When the vuln_func is called,&nbsp; 'saved ret ptr' is pushed onto the stack @stack_address_004CFCF8 and we enter the vulnerable function. <br />3. Function prologue kicks in:<br />&nbsp;&nbsp;&nbsp; push ebp // (saved old ebp) is pushed onto the stack @stack_address_004CFCF4<br />&nbsp;&nbsp;&nbsp; mov ebp, esp <br />4. After declaring local variables, stack cookie is fetched from .data section and xored with ebp and the final cookie is calculated. This is placed on top of the saved old ebp @ [ebp-4].<br />5. Note that there is no Exception Handler pointers in the vulnerable function's stack frame as I did not use any exception handling.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What if there is no Exception Handler as in our example? Well, we will try to send huge buffer and try to overwrite the default OS SE Handler. If we can do that, then GS Cookie can be bypassed.<br /><br />Other techniques to bypass GS Cookie:<br />1. GS Cookie can also be bypassed by leaking the static cookie from the .data section or from the stack if possible. <br />2. By brute forcing the cookie value etc. <br />But these are very uncommon and are limited to certain scenarios only.</p><p>&nbsp;<br /><span style="color: #04ff00;"><b><u>DEP</u>:</b></span> (Data Execution Prevention)<br />Usually, the code section in a program is marked as readable and executable while the data section is marked as either readable or readable and writable. The logic behind this is that the code need not undergo any change and is marked as readable. Since it needs to be executed as well, it is also marked as executable. However, the data may be initialized or non-initialized. It may need to be modified to initialize. So, it is marked as readable or readable and writable based on the type of data.</p><p>DEP prevents the data section from being executed. Whenever DEP is enabled, it prevents a section from being writable and executable at the same time! So, the data section will be writable but not executable. However, this default behaviour can be modified. Read <a href="https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention" target="_blank">this </a>msdn documentation on DEP to know more.&nbsp;</p><p>DEP is both a compiler option and a OS feature.<br />1. The compiler flag <span style="color: #e69138;"><b>/NXCOMPAT:NO</b></span> is used to disable DEP. (Note: DEP is enabled by default).<br />2. When it comes to OS. There are two variants of DEP:<br /><span>&nbsp;&nbsp; &nbsp;</span>i. Software enforced DEP: DEP is enforced on memory pages by software.<br /><span>&nbsp;&nbsp; &nbsp;</span>ii. Hardware enforced DEP: The processor enforces DEP on memory pages. NX ("No Execute", AMD processors) or XD ("Execute Disable", Intel processors) bit on DEP aware CPUs is used to mark certain parts of memory which are supposed to contain only data such as the default heap, stack etc as non executable.</p><p>Hardware DEP on Windows is system wide and has four configurable options:</p><p><span style="color: #3d85c6;"><b>1. Opt In: </b></span>It means only a few system programs and services are opted into DEP by default and if you want to enable DEP for a specific process then you need to opt that program in for DEP.<br />Enable OptIn: Right click on 'This PC' / "My Computer" --&gt; 'Advanced System Settings' --&gt; click on 'Advanced' tab --&gt; choose 'Performace: 
Settings' --&gt; click on 'Data Execution Prevention' tab --&gt; choose '
 Turn on DEP for essential Windows programs and services only'</p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/Opt%20In.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="637" data-original-width="800" height="510" src="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/Opt%20In.png" width="640" alt="ExploitMitigationsOptIn"/></a></div><p></p><p><span style="color: #3d85c6;"><b>2. Opt Out:</b></span> It means all programs and services are opted in by default and if you need to disable DEP for a specific process then you need to opt that program out of DEP.<br />Enable OptOut: Right click on 'This PC' / "My Computer" --&gt; 'Advanced System 
Settings' --&gt; click on 'Advanced' tab --&gt; choose 'Performace: 
Settings' --&gt; click on 'Data Execution Prevention' tab --&gt; choose '
 Turn on DEP for all programs and services except those I select'</p><p><a href="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/Opt%20Out.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="636" data-original-width="800" height="636" src="https://github.com/ElNino1511/blog/raw/main/Win32%20Exploitation/Exploit%20Mitigations/Opt%20Out.png" width="800" alt="ExploitMitigationsOptOut"/></a></p><p></p><p><span style="color: #3d85c6;"><b>3. Always ON:</b></span> DEP is enabled for all processes and services (without any exceptions)<br />Enable Always ON: Open a cmd as admin and run:&nbsp;</p><pre><code class="nohighlight nohljsln">bcdedit /set nx AlwaysOn</code></pre><p><span style="color: #3d85c6;"><b>4. Always OFF: </b></span>DEP is disabled for all processes and services (without any exceptions)<br />Enable Always OFF: Open a cmd as admin and run:&nbsp;</p><pre><code class="nohighlight nohljsln">bcdedit /set nx AlwaysOff</code></pre><p>Note: bcdedit means Boot Configuration Data Editor. It can also be used to set OptIn and OptOut.</p><p>Note: You need to restart your pc after changing the system wide DEP.<br /></p><p>Apart from these, the Windows OS also offers <span style="color: #e69138;"><b>SetProcessDEPPolicy </b></span>API to enable or disable DEP for a single process. However, it has limited functionality. As per the msdn article on <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setprocessdeppolicy" target="_blank">SetProcessDEPPolicy</a>: Quote"<span style="background-color: black;"><i>The SetProcessDEPPolicy function overrides the system DEP policy for the current process unless its DEP policy was specified at process creation. The system DEP policy setting must be OptIn or OptOut. If the system DEP policy is AlwaysOff or AlwaysOn, SetProcessDEPPolicy returns an error. After DEP is enabled for a process, subsequent calls to SetProcessDEPPolicy are ignored.</i></span>" It also mentions, "<span style="background-color: black;"><i>SetProcessDEPPolicy is supported for 32-bit processes only. If this function is called on a 64-bit process, it fails with ERROR_NOT_SUPPORTED.</i></span>" Also, read the above msdn link to understand the weird interaction between system wide DEP Policy, DEP-ATL thunk emulation, and SetProcessDEPPolicy.</p><p></p><p>All the DEP bypassing techniques fall into either of two categories:<br />&nbsp;&nbsp; &nbsp;<span style="color: #3d85c6;"><b>1.</b></span> Techniques that disable the DEP for that program:<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #e69138;"><b>a. SetProcessDEPPolicy</b></span><br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #e69138;"><b>b. NtSetInformationProcess</b></span><br />&nbsp;&nbsp; &nbsp;<span>&nbsp;&nbsp; &nbsp;</span>Based on the DEP policy in vogue, these functions may/may not disable DEP.<br />&nbsp;&nbsp; &nbsp;<span style="color: #3d85c6;"><b>2.</b></span> Techniques that create an 'executable' region: Under this category, the techniques can be further divided into two types:<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #674ea7;"><b> a.</b></span> Techniques that create a new executable region, copy the shellcode to that region and execute it.<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span style="color: #e69138;"><b> i. VirtualAlloc:</b></span> (requires chaining of 2 APIs)<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Variations: VirtualAlloc + Memcpy ; VirtualAlloc + WPM<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span style="color: #f6b26b;"><b><span style="color: #e69138;">&nbsp; ii. HeapCreate:</span> </b></span>(requires chaining of 3 APIs)<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Variations: HeapCreate + HeapAlloc + Memcpy ; HeapCreate + HeapAlloc + WPM ;<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #e69138;"><b>iii. WriteProcessMemory</b></span> → WriteProcessMemory is weird. It can copy the shellcode to a region marked as 'executable' even if it is not writable! WPM temporarily modifies the target executable region to 'writable and executable' and then reverts it back to 'executable' after finishing the copy.<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #674ea7;"><b> b. </b></span>Techniques that modify the present region to 'executable' and execute it.<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: #e69138;"><b>i. VirtualProtect:</b></span> (requires only 1 API)</p><p><br /></p><p><span style="color: #04ff00;"><b><u>ASLR</u>: </b></span>(Address Space Layout Randomization)</p><ul style="text-align: left;"><li>It is a <span style="color: #e69138;"><b>compiler </b></span>option.</li><li>The <span style="color: #e69138;"><b>/DYNAMICBASE:NO</b></span> compiler flag can be used to disable ASLR for a program. (Note: ASLR is enabled by default)</li><li>Unlike DEP, ASLR cannot be forced on programs. They need to be recompiled again with ASLR.</li><li>ASLR randomizes the base address at which a program (more accurately a module) is loaded in memory. However, it is not entirely random. Only the higher two bytes are randomized.<br />Ex: 32bit base address = xxxx0000</li><li>Introduced from Vista+.</li><li>The base address is randomized on every instance of the program and also when the OS is rebooted. So, closing a program and reopening it changes the base address and restarting the computer also changes the base address.<br /></li></ul><p>

</p>

<p></p><p></p>